# SOF-ELKÂ® Configuration File
# (C)2023 Lewes Technology Consulting, LLC
#
# This file contains processing steps for Zeek's DNS logs, normalizing them to existing mapppings for other DNS records
# Some portions orginally contributed by Justin Henderson

# Reference: https://docs.zeek.org/en/master/scripts/base/protocols/dns/main.zeek.html#type-DNS::Info

filter {
  if [type] == "zeek_dns" and "zeek_json" in [tags] {
    mutate {
      rename => {
        "[raw][uid]" => "[zeek][session_id]"
        "[raw][id.orig_h]" => "[source][ip]"
        "[raw][id.orig_p]" => "[source][port]"
        "[raw][id.resp_h]" => "[destination][ip]"
        "[raw][id.resp_p]" => "[destination][port]"
        "[raw][proto]" => "[network][transport]"
        "[raw][query]" => "query"
        "[raw][qtype_name]" => "query_type"
        "[raw][answers]" => "answer"
        "[raw][TTLs]" => "ttl"
        "[raw][rcode_name]" => "response_code"
        "[raw][trans_id]" => "transaction_id"
        "[raw][rtt]" => "rtt"
        "[raw][AA]" => "[dns_flags][authoritative]"
        "[raw][TC]" => "[dns_flags][truncated]"
        "[raw][RD]" => "[dns_flags][recursion_desired]"
        "[raw][RA]" => "[dns_flags][recursion_available]"
        "[raw][Z]" => "[dnssec_z]"
        "[raw][rejected]" => "[dns_flags][rejected]"
      }
    }

    if [raw][qclass_name] {
      translate {
        dictionary_path => "/usr/local/sof-elk/lib/dictionaries/zeek_dns_class2classabbrev.yaml"
        source => "qclass_name"
        target => "query_class"
      }
    }

    # populate the @timestamp field with the ts value
    date {
      match => [ "[raw][ts]", "UNIX" ]
    }
    translate {
      dictionary_path => "/usr/local/sof-elk/lib/dictionaries/ip_proto_zeek2int.yaml"
      source => "[network][transport]"
      target => "[network][iana_number]"
    }

    if [answer] and [query_type] != "CNAME" {
      grok {
        match => [ "answer", "^%{IP:answer.ip}$" ]
      }
    }

    if [source][ip] and [query] and [answer] {
      mutate {
        replace => { "message" => "DNS: %{[source][ip]} (%{query} -> %{answer})" }
      }
    } else if [source][ip] and [query] {
      mutate {
        replace => { "message" => "DNS: %{[source][ip]} (%{query} -> No response)"}
      }
    }

    mutate {
      convert => {
        "[network][iana_number]" => "integer"
      }
      remove_field => "raw"
    }
  }
}
